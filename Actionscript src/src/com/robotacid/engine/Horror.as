package com.robotacid.engine {
	import com.robotacid.ai.HorrorBrain;
	import com.robotacid.geom.Pixel;
	import com.robotacid.gfx.Renderer;
	import com.robotacid.phys.Collider;
	import com.robotacid.phys.FilterCollider;
	import flash.display.DisplayObject;
	import flash.display.MovieClip;
	import flash.geom.ColorTransform;
	import flash.geom.Rectangle;
	
	/**
	 * A creature generated by the FEAR Effect
	 * 
	 * It targets a given character and when it overlaps it, it drains their health
	 * 
	 * @author Aaron Steed, robotacid.com
	 */
	public class Horror extends Character {
		
		public var spawnRect:Rectangle;
		public var count:int;
		
		// A special state for the horror when it enters a level
		public static const SPAWNING:int = 8;
		
		public static const SPEED_MULTIPLIER:Number = 0.75;
		public static const DRAIN_RATE:Number = 1.0 / 90;
		public static const BLACK_TINT:ColorTransform = new ColorTransform(0, 0, 0);
		public static const RED_TINT:ColorTransform = new ColorTransform(1, 0, 0, 1, 200);
		public static const SPAWN_SPEED:Number = 1;
		public static const MIN_SPAWN_DIST:int = 5;
		public static const MAX_SPAWN_DIST:int = 15;
		public static const VOICES:Array = [
			["horror1", "horror2", "horror3", "horror4", "horror5", "horror6"],
			["fury1", "fury2", "fury3", "fury4", "fury5", "fury6"]
		];
		
		public function Horror(character:Character, count:int) {
			// the victim reference that is usually used for tracking the last character hit is used here
			// to track the target the horror intends to kill
			victim = character;
			this.count = count;
			
			var dest:Pixel = getSpawnLocation(character, game.world.map, game.mapTileManager.mapRect);
			super(new (character.gfx as Object).constructor, (dest.x + 0.5) * Game.SCALE, (dest.y + 1) * Game.SCALE, character.name, HORROR, character.level, true);
			
			gfx.transform.colorTransform = (character == game.player || character == game.minion) ? BLACK_TINT : RED_TINT;
			speed *= SPEED_MULTIPLIER;
			damage = victim.totalHealth * DRAIN_RATE;
			debrisType = (character == game.player || character == game.minion) ? Renderer.STONE : Renderer.BLOOD;
			
			spawnRect = collider.clone();
			spawnRect.y += collider.height - SPAWN_SPEED;
			spawnRect.height = SPAWN_SPEED;
			if(character == game.player || character == game.minion){
				game.console.print("he comes...");
				voice = VOICES[0];
			} else {
				game.console.print("your fury takes form...");
				voice = VOICES[1];
			}
			state = SPAWNING;
			brain = new HorrorBrain(this, victim);
		}
		
		override public function createCollider(x:Number, y:Number, properties:int, ignoreProperties:int, state:int = 0, positionByBase:Boolean = true):void {
			// characters are thinner than their graphics, so we have to read their widths from the stats
			var bounds:Rectangle = gfx.getBounds(gfx);
			var w:Number = stats["widths"][name];
			// horrors can wall walk
			collider = new FilterCollider(x - w * 0.5, y - bounds.height, w, bounds.height, Game.SCALE, properties, ignoreProperties, state);
			(collider as FilterCollider).setFilter(Collider.WALL, Collider.WALL | Collider.UP | Collider.DOWN, Collider.MAP_EDGE);
			collider.userData = this;
			mapX = (collider.x + collider.width * 0.5) * Game.INV_SCALE;
			mapY = (collider.y + collider.height * 0.5) * Game.INV_SCALE;
			collider.ignoreProperties |= Collider.CHARACTER | Collider.MONSTER_MISSILE | Collider.PLAYER_MISSILE | Collider.HORROR | Collider.GATE | Collider.MISSILE;
			collider.properties |= Collider.HORROR;
		}
		
		override public function main():void {
			
			tileCenter = (mapX + 0.5) * SCALE;
			if(state == WALKING && brain.target) brain.main();
			
			super.main();
			
			renderer.createDrips(spawnRect, 3, debrisType);
			if(!victim.indifferent && spawnRect.intersects(victim.collider)){
				victim.applyDamage(damage, "horror", 0, false, this, false);
				renderer.createDebrisRect(victim.collider, 0, 2, victim.debrisType);
			}
			
			if(!victim.active || !brain.target){
				count = 0;
				if(state == SPAWNING) state = WALKING;
			}
			
			if(state == SPAWNING){
				spawnRect.y -= SPAWN_SPEED;
				spawnRect.height += SPAWN_SPEED;
				if(spawnRect.height > collider.height){
					state = WALKING;
					game.world.restoreCollider(collider);
					spawnRect = collider;
				}
			} else {
				if(count) count--;
				else {
					death();
				}
			}
			
		}
		
		/* Just in case */
		override public function applyStun(delay:Number):void {
			return;
		}
		override public function applyWeaponEffects(item:Item):void {
			return;
		}
		
		override public function death(cause:String = "crushing", decapitation:Boolean = false, aggressor:Character = null):void{
			active = false;
			renderer.createDrips(spawnRect, 40, debrisType);
			if(!active && collider.world) collider.world.removeCollider(collider);
		}
		
		override public function render():void {
			var mc:MovieClip = gfx as MovieClip;
			
			if(mc.currentLabel != "idle"){
				mc.gotoAndStop("idle");
			}
			
			if(state != SPAWNING){
				if(victim.mapX < mapX && mc.scaleX != -1) mc.scaleX = -1;
				else if(victim.mapX > mapX && mc.scaleX != 1) mc.scaleX = 1;
				gfx.x = ((collider.x + collider.width * 0.5) + 0.5) >> 0;
				gfx.y = ((collider.y + collider.height) + 0.5) >> 0;
				matrix = gfx.transform.matrix;
				matrix.tx -= renderer.bitmap.x;
				matrix.ty -= renderer.bitmap.y;
				renderer.bitmapData.draw(gfx, matrix, gfx.transform.colorTransform);
			} else {
				if((looking & LEFT) && mc.scaleX != -1) mc.scaleX = -1;
				else if((looking & RIGHT) && mc.scaleX != 1) mc.scaleX = 1;
				gfx.x = ((spawnRect.x + spawnRect.width * 0.5) + 0.5) >> 0;
				gfx.y = ((spawnRect.y + collider.height) + 0.5) >> 0;
				var clipRect:Rectangle = new Rectangle( -renderer.bitmap.x + (gfx.x - gfx.width * 0.5), -renderer.bitmap.y + spawnRect.y, gfx.width, spawnRect.height);
				matrix = gfx.transform.matrix;
				matrix.tx -= renderer.bitmap.x;
				matrix.ty -= renderer.bitmap.y;
				renderer.bitmapData.draw(gfx, matrix, gfx.transform.colorTransform, null, clipRect);
			}
			
		}
		
		/* Get a random location to spawn a Horror from (at a visible distance from the target and on a platform) */
		public static function getSpawnLocation(target:Character, map:Vector.<Vector.<int>>, mapRect:Rectangle):Pixel{
			var finish:Pixel = new Pixel();
			var vx:int, vy:int, maxEdge:int = MAX_SPAWN_DIST;
			do{
				finish.x = target.mapX + ( -maxEdge + game.random.range(maxEdge * 2));
				finish.y = target.mapY + ( -maxEdge + game.random.range(maxEdge * 2));
				vx = target.mapX - finish.x;
				vy = target.mapY - finish.y;
				if(vx < 0) vx = -vx;
				if(vy < 0) vy = -vy;
				
				// the target may be far away from any platforms on a long ladder
				if(maxEdge > map.length && maxEdge > map[0].length) maxEdge++;
				
			} while(
				vx + vy < MIN_SPAWN_DIST ||
				finish.x < 1 ||
				finish.y < 1 ||
				finish.x > map[0].length - 2 ||
				finish.y > map.length - 2 ||
				(map[finish.y][finish.x] & Collider.WALL) ||
				!(map[finish.y + 1][finish.x] & Collider.UP) ||
				(map[finish.y + 1][finish.x] & Collider.CHAOS) ||
				!mapRect.contains((finish.x + 0.5) * Game.SCALE, (finish.y + 0.5) * Game.SCALE)
			);
			return finish;
		}
		
	}

}